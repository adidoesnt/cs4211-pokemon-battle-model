#define active 1; //trainer active
#define inactive 0; //trainer inactive
#define win 2; // trainer wins
#define lose -1; //trainer loses
var trainer[2] = [active, inactive]; //initial trainer states
var health[2] = [10, 10]; // pokemon's HP
// var levels[2] = [80, 80]; // pokemon's level

rotate() = 
        [trainer[0] == active && trainer[1] == inactive]switch{trainer[0] = inactive; trainer[1] = active} -> move(1)
        []
        [trainer[1] == active && trainer[0] == inactive]switch{trainer[1] = inactive; trainer[0] = active} -> move(0);   

move(i) = 
        [i == 0]reduceFoeHealth.i{health[1] = health[1] - 2} -> end()
        []
        [i == 1]reduceFoeHealth.i{health[0] = health[0] - 2} -> end(); 

end() = [health[0] <= 0]trainer0win{trainer[1] = win; trainer[0] = lose} -> Stop
        []
        [health[1] <= 0]trainer1win{trainer[0] = win; trainer[1] = lose} -> Stop
        []
        [health[1] > 0 && health[0] > 0] rotate();

start() = 
	trainer0start{trainer[0] = active; trainer[1] = inactive} -> rotate()
	[]
	trainer1start{trainer[1] = active; trainer[0] = inactive} -> rotate();

simulate = start();

#define trainer0wins (trainer[0] == win && trainer[1] == lose);
#define trainer1wins (trainer[1] == win && trainer[0] == lose);
#define bothtrainerswin (trainer[0] == win && trainer[1] == win);
#define bothtrainerslose (trainer[0] == lose && trainer[1] == lose);

#assert simulate reaches trainer0wins;
#assert simulate reaches trainer1wins;
#assert simulate reaches bothtrainerswin;
#assert simulate reaches bothtrainerslose;